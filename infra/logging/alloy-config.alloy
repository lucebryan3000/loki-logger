logging {
  level = "info"
}

discovery.docker "all" {
  host             = "unix:///var/run/docker.sock"
  refresh_interval = "30s"
}

discovery.relabel "docker_filtered" {
  targets = discovery.docker.all.targets

  // Keep only selected compose projects (bounded allowlist):
  // - vllm (includes codeswarm-mcp)
  // - hex  (includes hex-atlas-*)
  rule {
    action        = "keep"
    source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
    regex         = "^(vllm|hex)$"
  }

  // Explicitly drop the logging stack even if keep rules are expanded later.
  rule {
    action        = "drop"
    source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
    regex         = "^logging$"
  }

  // --- label schema (Sprint-3 Phase 2) ---
  // Stable low-cardinality labels derived from compose metadata.
  // stack = compose project (vllm|hex)
  rule {
    action        = "replace"
    source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
    target_label  = "stack"
  }

  // service = compose service (bounded by compose)
  rule {
    action        = "replace"
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    target_label  = "service"
  }

  // source_type = docker (constant)
  rule {
    action        = "replace"
    source_labels = ["__address__"]
    target_label  = "source_type"
    regex         = ".*"
    replacement   = "docker"
  }
  // --- end label schema ---

}


loki.source.docker "dockerlogs" {
  host       = "unix:///var/run/docker.sock"
  targets    = discovery.relabel.docker_filtered.output
  forward_to = [loki.process.docker.receiver]
}

// journald -> Loki (optional)
loki.source.journal "journald" {
  forward_to = [loki.process.journald.receiver]
}

// rsyslog TCP syslog ingress (localhost port mapping on host)
loki.source.syslog "rsyslog" {
  listener {
    address  = "0.0.0.0:1514"
    protocol = "tcp"
    labels = {
      log_source  = "rsyslog_syslog",
      source_type = "syslog",
    }
  }

  // Route through main processor so syslog also gets shared static labels
  // and redaction stages before write.
  forward_to = [loki.process.main.receiver]
}

// tool sink
local.file_match "tool_sink" {
  path_targets = [{ "__path__" = "/host/home/luce/_logs/*.log" }]
}
loki.source.file "tool_sink" {
  targets       = local.file_match.tool_sink.targets
  tail_from_end = true
  forward_to    = [loki.process.tool_sink.receiver]
}

// telemetry
local.file_match "telemetry" {
  path_targets = [{ "__path__" = "/host/home/luce/_telemetry/*.jsonl" }]
}
loki.source.file "telemetry" {
  targets       = local.file_match.telemetry.targets
  tail_from_end = true
  forward_to    = [loki.process.telemetry.receiver]
}

// GPU telemetry (host nvidia-smi CSV mirror)
local.file_match "gpu_telemetry_gpu" {
  path_targets = [{ "__path__" = "/host/home/luce/_telemetry/gpu/gpu-live.csv" }]
}

loki.source.file "gpu_telemetry_gpu" {
  targets       = local.file_match.gpu_telemetry_gpu.targets
  tail_from_end = true
  forward_to    = [loki.process.gpu_telemetry_gpu.receiver]
}

local.file_match "gpu_telemetry_proc" {
  path_targets = [{ "__path__" = "/host/home/luce/_telemetry/gpu/gpu-proc.csv" }]
}

loki.source.file "gpu_telemetry_proc" {
  targets       = local.file_match.gpu_telemetry_proc.targets
  tail_from_end = true
  forward_to    = [loki.process.gpu_telemetry_proc.receiver]
}

// --- NVIDIA telemetry-as-logs (Sprint-3 Phase 4a) ---
local.file_match "nvidia_telem" {
  path_targets = [
    { "__path__" = "/host/home/luce/apps/vLLM/logs/telemetry/nvidia/raw-30s.jsonl" },
    { "__path__" = "/host/home/luce/apps/vLLM/logs/telemetry/nvidia/raw-60s.jsonl" },
    { "__path__" = "/host/home/luce/apps/vLLM/logs/telemetry/nvidia/proc-5m.jsonl" },
    { "__path__" = "/host/home/luce/apps/vLLM/logs/telemetry/nvidia/health-15m.jsonl" },
    { "__path__" = "/host/home/luce/apps/vLLM/logs/telemetry/nvidia/alerts.jsonl" },
    { "__path__" = "/host/home/luce/apps/vLLM/logs/telemetry/nvidia/burst/*.jsonl" },
  ]
}

loki.source.file "nvidia_telem" {
  targets       = local.file_match.nvidia_telem.targets
  tail_from_end = true
  forward_to    = [loki.process.nvidia_telem.receiver]
}

loki.process "nvidia_telem" {
  stage.static_labels {
    values = {
      env         = "sandbox",
      stack       = "vllm",
      service     = "vllm",
      source_type = "file",
      log_source  = "nvidia_telem",
      telemetry_tier = "raw30",
    }
  }

  // --- redaction (phase 7b remediation) ---
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  // Normalize NVIDIA failure semantics for cross-source error dashboards.
  stage.match {
    selector = "{log_source=\"nvidia_telem\"} |~ \"(?i)(error|fail|failed|critical|panic|xid|nvrm|oom|overheat|throttl|power limit)\""
    stage.static_labels {
      values = {
        level = "error",
      }
    }
  }

  forward_to = [loki.write.default.receiver]
}
// --- end NVIDIA telemetry-as-logs ---


// CodeSwarm MCP logs (vLLM host bind)
local.file_match "codeswarm_mcp" {
  path_targets = [{ "__path__" = "/host/home/luce/apps/vLLM/_data/mcp-logs/*.log" }]
}


loki.source.file "codeswarm_mcp" {
  targets       = local.file_match.codeswarm_mcp.targets
  tail_from_end = true
  forward_to    = [loki.process.codeswarm.receiver]
}

// --- VS Code Server logs ---
local.file_match "vscode_server" {
  path_targets = [
    { "__path__" = "/host/home/luce/.vscode-server/**/*.log" },
    { "__path__" = "/host/home/luce/.vscode-server/**/log.txt" },
  ]
}

loki.source.file "vscode_server" {
  targets       = local.file_match.vscode_server.targets
  tail_from_end = true
  forward_to    = [loki.process.vscode.receiver]
}
// --- end VS Code Server logs ---

// --- Codex TUI logs ---
local.file_match "codex_tui" {
  path_targets = [{ "__path__" = "/host/home/luce/.codex/log/codex-tui.log" }]
}

loki.source.file "codex_tui" {
  targets       = local.file_match.codex_tui.targets
  tail_from_end = true
  forward_to    = [loki.process.codex_tui.receiver]
}
// --- end Codex TUI logs ---

// --- Host file logs (selected) ---
local.file_match "host_wireguard_log" {
  path_targets = [{ "__path__" = "/host/var/log/wireguard-client-manager.log" }]
}

loki.source.file "host_wireguard_log" {
  targets       = local.file_match.host_wireguard_log.targets
  tail_from_end = true
  forward_to    = [loki.process.host_wireguard_log.receiver]
}

local.file_match "host_codeswarm_log" {
  path_targets = [{ "__path__" = "/host/var/log/codeswarm.log" }]
}

loki.source.file "host_codeswarm_log" {
  targets       = local.file_match.host_codeswarm_log.targets
  tail_from_end = true
  forward_to    = [loki.process.host_codeswarm_log.receiver]
}

local.file_match "host_apt_history" {
  path_targets = [{ "__path__" = "/host/var/log/apt/history.log" }]
}

loki.source.file "host_apt_history" {
  targets       = local.file_match.host_apt_history.targets
  tail_from_end = true
  forward_to    = [loki.process.host_apt_history.receiver]
}
// --- end Host file logs (selected) ---

 loki.process "main" {
  stage.static_labels {
    values = {
      env            = "sandbox",
      syslog_channel = "general",
      syslog_level   = "info",
    }
  }

  stage.metrics {
    metric.counter {
      name              = "codeswarm_syslog_lines_total"
      description       = "Total syslog lines processed by main pipeline"
      action            = "inc"
      match_all         = true
      max_idle_duration = "24h"
    }
  }

  stage.decolorize {}

  // High ceiling safety valve for noisy syslog bursts in sandbox.
  stage.limit {
    rate  = 5000
    burst = 10000
    drop  = true
  }

  // Drop known historical atlas-mcp flap noise after root-cause remediation.
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"(?i)(Error: Cannot find module '/home/luce/apps/hex/dist/mcp/server/index[.]js'|atlas-mcp[.]service: Main process exited|atlas-mcp[.]service: Failed with result 'exit-code'|throw err[;]?)\""
    stage.static_labels {
      values = {
        noise_class = "atlas_mcp_flap",
      }
    }
    stage.drop {
      expression = ".*"
    }
  }

  // Drop low-value docker daemon healthcheck/shutdown chatter that can dominate
  // error-like dashboards without representing actionable stack failures.
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"(?i)(Health check for container .* OCI runtime exec failed|copy stream failed.*reading from a closed fifo|ShouldRestart failed, container will not be restarted|restart canceled|hasBeenManuallyStopped=true|Container failed to exit within 10s of signal 15 - using the force)\""
    stage.static_labels {
      values = {
        noise_class = "docker_runtime_chatter",
      }
    }
    stage.drop {
      expression = ".*"
    }
  }

  // Drop package manager noise (apt, dpkg, update-notifier, unattended-upgrades).
  // These are low-value automated events that clutter error dashboards.
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"(?i)(apt:|dpkg:|packagekit:|unattended-upgrade|update-notifier|apt-get|Unpacking |Setting up |Processing triggers|^Finished update-notifier)\""
    stage.static_labels {
      values = {
        noise_class = "package_manager",
      }
    }
    stage.drop {
      expression = ".*"
    }
  }

  // syslog channel tagging for better security triage in Grafana/Loki.
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"(?i)ufw\""
    stage.static_labels {
      values = {
        syslog_channel  = "ufw",
        security_domain = "firewall",
        service_name    = "ufw",
      }
    }
  }

  // PAM authentication events (sudo and cron)
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"pam_unix.*sudo\""
    stage.static_labels {
      values = {
        syslog_channel  = "auth",
        security_domain = "auth",
        service_name    = "sudo",
      }
    }
  }

  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"pam_unix.*cron\""
    stage.static_labels {
      values = {
        syslog_channel  = "auth",
        security_domain = "auth",
        service_name    = "cron",
      }
    }
  }

  // SSH authentication and generic auth
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"(?i)(sshd|authentication failure|session opened for user|session closed for user)\""
    stage.static_labels {
      values = {
        syslog_channel  = "auth",
        security_domain = "auth",
        service_name    = "sshd",
      }
    }
  }

  // rsyslog daemon action messages
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"action.*omfwd\""
    stage.static_labels {
      values = {
        service_name = "rsyslog",
      }
    }
  }

  // Network interface state changes (kernel networking)
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"(?i)(renamed from|entered.*state|device|interface)\""
    stage.static_labels {
      values = {
        service_name = "kernel",
      }
    }
  }

  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"(?i)(warn|warning|degraded|retry|backoff|throttl)\""
    stage.static_labels {
      values = {
        syslog_level = "warn",
        level        = "warning",
      }
    }
  }

  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"(?i)(error|err|fatal|panic|fail|failed|exit-code|denied|refused|operation not permitted|segfault|oom|timeout)\" !~ \"(?i)^Finished update-notifier-download[.]service\""
    stage.metrics {
      metric.counter {
        name              = "codeswarm_syslog_error_lines_total"
        description       = "Error-like syslog lines matched by inference patterns"
        action            = "inc"
        match_all         = true
        max_idle_duration = "24h"
      }
    }
    stage.static_labels {
      values = {
        syslog_level = "error",
        level        = "error",
      }
    }
  }

  // Prefer structured syslog severity label when available.
  stage.match {
    selector = "{source_type=\"syslog\",level=~\"(?i)(warn|warning)\"}"
    stage.static_labels {
      values = {
        syslog_level = "warn",
        level        = "warning",
      }
    }
  }

  stage.match {
    selector = "{source_type=\"syslog\",level=~\"(?i)(err|error|crit|critical|alert|emerg|fatal|panic)\"}"
    stage.metrics {
      metric.counter {
        name              = "codeswarm_syslog_structured_error_lines_total"
        description       = "Structured syslog lines with error severity labels"
        action            = "inc"
        match_all         = true
        max_idle_duration = "24h"
      }
    }
    stage.static_labels {
      values = {
        syslog_level = "error",
        level        = "error",
      }
    }
  }

  // --- Service name attribution (Sprint-4 Phase 1) ---
  // Extract service names from syslog to reduce unknown_service volume.

  // Internal daemon cycle markers (loki_ops orchestration)
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"DAEMON_CYCLE\""
    stage.static_labels {
      values = {
        service_name = "loki_ops",
      }
    }
  }

  // Kernel and core system processes
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"(?i)(kernel|systemd|init|systemd-logind)\""
    stage.regex {
      expression = "(?P<core_service>kernel|systemd|init|systemd-logind)"
    }
    stage.labels {
      values = {
        service_name = "core_service",
      }
    }
  }

  // System daemons (process[PID]: pattern)
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"[a-z0-9_-]+\\\\[\\\\d+\\\\]:\""
    stage.regex {
      expression = "(?P<daemon_service>[a-z0-9_-]+)\\[\\d+\\]:"
    }
    stage.labels {
      values = {
        service_name = "daemon_service",
      }
    }
  }

  // Cron scheduler jobs
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"CRON\\\\[\" "
    stage.static_labels {
      values = {
        service_name = "cron",
      }
    }
  }

  // systemd-resolved DNS messages (no [PID] prefix)
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"(?i)Using degraded feature set\""
    stage.static_labels {
      values = {
        service_name = "systemd-resolved",
      }
    }
  }

  // Improve service attribution for syslog lines that include systemd unit names.
  // (This runs last, so .service extraction takes precedence over generic daemon match)
  stage.match {
    selector = "{source_type=\"syslog\"} |~ \"[A-Za-z0-9_.@-]+[.]service\""
    stage.regex {
      expression = "(?P<syslog_service>[A-Za-z0-9_.@-]+[.]service)"
    }
    stage.labels {
      values = {
        service_name = "syslog_service",
      }
    }
  }

  // --- redaction (Sprint-3 Phase 1) ---
  // Fake-secret patterns only; prevent credentials from being stored in Loki.
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  forward_to = [loki.write.default.receiver]

}

loki.process "codeswarm" {
  stage.static_labels {
    values = {
      env        = "sandbox",
      log_source = "codeswarm_mcp",
    }
  }

  // Join multiline stack traces before JSON parsing / label extraction.
  stage.multiline {
    firstline     = "^(\\{|[0-9]{4}-[0-9]{2}-[0-9]{2}[ T][0-9]{2}:[0-9]{2}:[0-9]{2})"
    max_wait_time = "3s"
    max_lines     = 256
  }

  // --- safe JSON parsing (Sprint-3 Phase 3) ---
  // Parse JSON lines; do not drop malformed lines.
  stage.decolorize {}

  stage.metrics {
    metric.counter {
      name              = "codeswarm_mcp_lines_total"
      description       = "Total codeswarm_mcp lines processed"
      action            = "inc"
      match_all         = true
      max_idle_duration = "24h"
    }
  }

  stage.json {
    expressions = {
      mcp_kind  = "kind",
      mcp_tool  = "tool",
      mcp_level = "level",
    }
  }

  // Promote only bounded fields to labels (selected via live probe; <=20 unique values).
  stage.labels {
    values = {
      mcp_kind  = "mcp_kind",
      mcp_tool  = "mcp_tool",
      mcp_level = "mcp_level",
      level     = "mcp_level",
    }
  }
  // --- end safe JSON parsing ---

  // Normalize failure semantics so dashboards can rely on level labels.
  stage.match {
    selector = "{log_source=\"codeswarm_mcp\"} |~ \"(?i)(Failed with result|Main process exited|Failed to start|Operation not permitted|exit-code)\""
    stage.static_labels {
      values = {
        level = "error",
      }
    }
  }

  // --- redaction (Sprint-3 Phase 1) ---
  // Fake-secret patterns only; prevent credentials from being stored in Loki.
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  forward_to = [loki.write.default.receiver]
}

// --- VS Code Server processor ---
loki.process "vscode" {
  stage.static_labels {
    values = {
      env          = "sandbox",
      log_source   = "vscode_server",
      service_name = "vscode_server",
    }
  }

  stage.decolorize {}

  stage.metrics {
    metric.counter {
      name              = "codeswarm_vscode_lines_total"
      description       = "Total vscode_server lines processed"
      action            = "inc"
      match_all         = true
      max_idle_duration = "24h"
    }
  }

  stage.multiline {
    firstline     = "^([0-9]{4}-[0-9]{2}-[0-9]{2}|\\[[0-9]{2}:[0-9]{2}:[0-9]{2}\\]|\\{)"
    max_wait_time = "3s"
    max_lines     = 256
  }

  // Suppress known benign editor/plugin churn that produces false-positive
  // "error-like" hits in aggregated dashboards.
  stage.match {
    selector = "{log_source=\"vscode_server\"} |~ \"(?i)(npm warn Unknown project config|Melissa[.]ai:.*state: exec-error)\""
    stage.static_labels {
      values = {
        noise_class = "editor_plugin_chatter",
      }
    }
    stage.drop {
      expression = ".*"
    }
  }

  // Suppress noisy VS Code extension probe failures that are non-actionable in
  // this sandbox and repeatedly pollute error dashboards.
  stage.match {
    selector = "{log_source=\"vscode_server\"} |~ \"(?i)(Failed to load config error=.*AgentRoleToml|Failed to load apps list error=.*object Object|git config failed: Failed to execute git)\""
    stage.static_labels {
      values = {
        noise_class = "vscode_extension_probe",
      }
    }
    stage.drop {
      expression = ".*"
    }
  }

  // Normalize recurring opencode-local failures for alerting and dashboards.
  stage.match {
    selector = "{log_source=\"vscode_server\"} |~ \"MCP server \\\"opencode-local\\\": Connection error: Failed to reconnect SSE stream\""
    stage.static_labels {
      values = {
        service_name  = "opencode-local",
        level         = "error",
        failure_class = "mcp_sse_reconnect",
      }
    }
  }

  stage.match {
    selector = "{log_source=\"vscode_server\"} |~ \"(?i)(Failed with result|Main process exited|Failed to start|Operation not permitted|exit-code)\""
    stage.static_labels {
      values = {
        level = "error",
      }
    }
  }

  // Redaction â€” same patterns as main/codeswarm processors
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }

  forward_to = [loki.write.default.receiver]
}
// --- end VS Code Server processor ---

// --- Docker processor ---
loki.process "docker" {
  stage.static_labels {
    values = {
      env        = "sandbox",
      log_source = "docker",
    }
  }

  // --- redaction ---
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  stage.decolorize {}

  forward_to = [loki.write.default.receiver]
}

// --- Journald processor ---
loki.process "journald" {
  stage.static_labels {
    values = {
      env        = "sandbox",
      log_source = "journald",
    }
  }

  // --- redaction ---
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  stage.decolorize {}

  forward_to = [loki.write.default.receiver]
}

// --- Tool Sink processor ---
loki.process "tool_sink" {
  stage.static_labels {
    values = {
      env        = "sandbox",
      log_source = "tool_sink",
    }
  }

  // --- redaction ---
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  forward_to = [loki.write.default.receiver]
}

// --- Telemetry processor ---
loki.process "telemetry" {
  stage.static_labels {
    values = {
      env        = "sandbox",
      log_source = "telemetry",
    }
  }

  // --- redaction ---
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  // Keep failure-semantics normalization active for telemetry stream.
  stage.match {
    selector = "{log_source=\"telemetry\"} |~ \"(?i)(error|fail|failed|critical|panic|timeout|exception)\""
    stage.static_labels {
      values = {
        level = "error",
      }
    }
  }

  forward_to = [loki.write.default.receiver]
}

// --- Codex TUI processor ---
loki.process "codex_tui" {
  stage.static_labels {
    values = {
      env          = "sandbox",
      log_source   = "codex_tui",
      source_type  = "file",
      service_name = "codex_tui",
    }
  }

  stage.decolorize {}

  stage.metrics {
    metric.counter {
      name              = "codeswarm_codex_lines_total"
      description       = "Total codex_tui lines processed"
      action            = "inc"
      match_all         = true
      max_idle_duration = "24h"
    }
  }

  // --- redaction ---
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  stage.multiline {
    firstline     = "^([0-9]{4}-[0-9]{2}-[0-9]{2}|\\{)"
    max_wait_time = "3s"
    max_lines     = 256
  }

  stage.match {
    selector = "{log_source=\"codex_tui\"} |~ \"(?i)(Failed with result|Main process exited|Failed to start|Operation not permitted|exit-code)\""
    stage.static_labels {
      values = {
        level = "error",
      }
    }
  }

  // Codex execution trace lines are high-volume and non-actionable for ops
  // dashboards in this sandbox.
  stage.match {
    selector = "{log_source=\"codex_tui\"} |~ \"(?i)(Ran set -euo pipefail|ToolCall: (exec_command|apply_patch|write_stdin|list_mcp_resources|list_mcp_resource_templates|read_mcp_resource|update_plan|multi_tool_use[.]parallel))\""
    stage.static_labels {
      values = {
        noise_class = "codex_exec_trace",
      }
    }
    stage.drop {
      expression = ".*"
    }
  }

  forward_to = [loki.write.default.receiver]
}
// --- end Codex TUI processor ---

// --- Host wireguard log processor ---
loki.process "host_wireguard_log" {
  stage.static_labels {
    values = {
      env         = "sandbox",
      log_source  = "host_wireguard",
      source_type = "file",
    }
  }

  // --- redaction ---
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  forward_to = [loki.write.default.receiver]
}
// --- end Host wireguard log processor ---

// --- Host codeswarm log processor ---
loki.process "host_codeswarm_log" {
  stage.static_labels {
    values = {
      env         = "sandbox",
      log_source  = "host_codeswarm",
      source_type = "file",
    }
  }

  // --- redaction ---
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  forward_to = [loki.write.default.receiver]
}
// --- end Host codeswarm log processor ---

// --- Host apt history processor ---
loki.process "host_apt_history" {
  stage.static_labels {
    values = {
      env         = "sandbox",
      log_source  = "host_apt",
      source_type = "file",
    }
  }

  // --- redaction ---
  stage.replace {
    expression = "(?i)\\bbearer\\s+([A-Za-z0-9._~-]+)\\b"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bcookie\\s*[:=]\\s*([^;\\s\\r\\n]+)"
    replace    = "[REDACTED]"
  }
  stage.replace {
    expression = "(?i)\\bapi[_-]?key\\s*[:=]\\s*([A-Za-z0-9._~-]+)"
    replace    = "[REDACTED]"
  }
  // --- end redaction ---

  forward_to = [loki.write.default.receiver]
}
// --- end Host apt history processor ---

// --- GPU telemetry processors ---
loki.process "gpu_telemetry_gpu" {
  stage.regex {
    expression = "^[^,]+,(?P<gpu_name>[^,]+),(?P<gpu_util>[0-9.]+),(?P<memory_pct>[0-9.]+),(?P<memory_used_mib>[0-9.]+),(?P<memory_total_mib>[0-9.]+),(?P<temp_c>[0-9.]+),(?P<power_w>[0-9.]+)$"
  }

  stage.labels {
    values = {
      gpu_name = "gpu_name",
    }
  }

  stage.static_labels {
    values = {
      env         = "sandbox",
      log_source  = "gpu_telemetry",
      source_type = "gpu_csv",
      host        = "codeswarm",
      stream      = "gpu",
    }
  }

  forward_to = [loki.write.default.receiver]
}

loki.process "gpu_telemetry_proc" {
  stage.regex {
    expression = "^[^,]+,(?P<pid>[0-9]+),(?P<process_name>[^,]+),(?P<used_gpu_memory_mib>[0-9.]+)$"
  }

  stage.static_labels {
    values = {
      env         = "sandbox",
      log_source  = "gpu_telemetry",
      source_type = "gpu_csv",
      host        = "codeswarm",
      stream      = "proc",
    }
  }

  forward_to = [loki.write.default.receiver]
}

loki.write "default" {
  endpoint {
    url                 = "http://loki:3100/loki/api/v1/push"
    batch_wait          = "1s"
    batch_size          = "2MiB"
    min_backoff_period  = "500ms"
    max_backoff_period  = "5m"
    max_backoff_retries = 20
  }

  external_labels = {
    cluster  = "codeswarm-sandbox",
    pipeline = "alloy",
  }
}
